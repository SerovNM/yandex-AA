/*
Если задана строка s, содержащая круглые скобки и буквы, удалите минимальное количество недопустимых скобок, чтобы сделать входную строку валидной.

Верните список уникальных строк, которые являются допустимыми при минимальном количестве удалений. Вы можете вернуть ответ в любом порядке.



Пример 1:

Вход: s = "()()()()".
Выход: ["(())()","()()()"]
Пример 2:

Вход: s = "(a)())()"
Выходные данные: ["(a())()","(a)()()"].
Пример 3:

Ввод: s = ")("
Выходные данные: [""]

 */

//BFS

var removeInvalidParentheses = function(s) {
    const result = [];
    // чтобы возвращать только уникальные валидные строки, отслеживаем уже обработанные строки
    const visited = new Set();
    const queue = [s];    // Применяем метод BFS с использованием очереди
    visited.add(s);    // Добавляем исходную строку в набор посещенных (обрабатываем сначала)

    let found = false;

    while(queue.length) {
        // Обрабатываем один уровень за раз - `size` будет количеством валидных строк на каждом уровне
        // Рассмотрим случай, когда первая строка недопустима, и мы добавляем другие строки в очередь
        // (удаляя по одному символу из строки), но вторая строка на том же уровне допустима.
        // Затем нам не нужно обрабатывать следующие добавленные строки на следующем уровне.
        const size = queue.length;
        for(let k = 0; k < size; ++k) {
            const str = queue.shift();    // Извлекаем из очереди (здесь O(n), так как мы используем массив, можно использовать связанный список для получения времени O(1))
            if(hasValidParentheses(str)) {
                found = true;
                result.push(str);
            }
            // Если найдена допустимая строка, необходимо перейти к следующему уровню удаления скобок
            // достаточно обработать все строки, находящиеся в очереди, чтобы все допустимые строки на этом уровне были добавлены к результату
            if(!found) {
                // На первой итерации один символ будет удален из исходной строки
                // на второй итерации два символа будут удалены из исходной строки
                // (по одному из каждой строки, сформированные путем удаления одного символа ранее)
                for(let i = 0; i < str.length; ++i) {
                    // Пропускаем любые другие символы
                    if(str[i] !== '(' && str[i] !== ')') {
                        continue;
                    }
                    // Удаление i-го символа
                    const nextStr = str.substring(0, i) + str.substring(i + 1);    // O(S) [S - длина `str`]
                    if(!visited.has(nextStr)) {
                        queue.push(nextStr);
                        visited.add(nextStr);
                    }
                }
            }
        }
    }
    return result;
};

// Отслеживаем скобки с использованием переменной счетчика
// если встречается `(`, увеличиваем счетчик, а если `)`, уменьшаем его
// если в какой-то момент значение счетчика становится отрицательным, это означает, что строка недопустима (покрывает случай, когда `)` больше)
// также нужно учесть случай, когда `(` больше, поэтому в конце мы можем проверить, равно ли значение счетчика 0 (равно и допустимо ли количество скобок) или нет
function hasValidParentheses(s) {    // O(S) [S - длина строки, которая в худшем случае равна `n`]
    let count = 0;
    for(let i = 0; i < s.length; ++i) {
        if(s[i] === '(') {
            ++count;
        } else if(s[i] === ')') {
            --count;
        }
        if(count < 0) {
            return false;
        }
    }
    return count === 0;
}
