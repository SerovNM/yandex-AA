//Учитывая массив асинхронных функций functions и ограничение пула n, верните асинхронную функцию promisePool. Он должен возвращать обещание, которое разрешается, когда разрешаются все функции ввода.
//
// Лимит пула определяется как максимальное количество ожидающих выполнения обещаний, которые могут быть выполнены одновременно. promisePool следует начать выполнение как можно большего числа функций и продолжить выполнение новых функций, когда старые обещания будут выполнены. promisePool должно выполняться functions[i] затем, functions[i + 1] затем functions[i + 2] и т.д. Когда последнее обещание будет выполнено, promisePool также должно быть выполнено.
//
// Например, if n = 1, promisePool будет выполнять последовательно по одной функции за раз. Однако, если n = 2, сначала он выполняет две функции. Когда любая из двух функций разрешится, должна быть выполнена третья функция (если доступна), и так далее, пока не останется функций для выполнения.
//
// Вы можете предположить, что все functions никогда не отклоняются. Для promisePool допустимо возвращать обещание, которое принимает любое значение.


//Смысл в том, что в моменте может выполняться только n операций
//В списке операций предыдущая может выполняться после следующей
//необходимо сделать так чтобы в моменте выполнялось не более n функций
var promisePool = async function (functions, n) {
        async function evaluateNext() { // 2 функция, которая будет вызываться n раз
            if (functions.length === 0) return; //если массив функций пустой, то выходим
            const fn = functions.shift(); //в переменную fn помещаем первую функцию из массива и из массива её удаляем
            await fn(); //вызываем функцию и ждем её выполнения
            await evaluateNext(); //рекурсивно начинается выполнение родительской функции
        }
        const nPromises = Array(n).fill().map(evaluateNext); // 1 создаем пустой массив длинной n и по очереди будем вызывать функции
        await Promise.all(nPromises);
}
