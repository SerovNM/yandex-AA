/**
 * В этом случае массив nums может содержать дубликаты и не обязательно
 * отсортирован в строго возрастающем порядке.
 * Тем не менее, он все еще повернут в некотором неизвестном индексе k до передачи в функцию.
 *
 * Требуется найти целевое значение target в массиве nums после поворота.
 * Задача состоит в том, чтобы вернуть true, если целевое значение присутствует в массиве nums,
 * и false, если его нет.
 */

/**
 */
var search = function(nums, target) {
    let low = 0, high = nums.length - 1; // Устанавливаем начальные значения для нижней и верхней границ диапазона поиска

    while (low <= high) { // Пока нижняя граница не превышает верхнюю
        let mid = Math.floor((low + high) / 2); // Вычисляем индекс среднего элемента
        if (nums[mid] === target) return true; // Если средний элемент равен целевому значению, возвращаем true

        if (nums[low] === nums[mid]) { // Если значения в начале и в середине равны
            low++; // Увеличиваем нижнюю границу и продолжаем цикл
            continue;
        }

        if (nums[low] <= nums[mid]) { // Если левая часть массива отсортирована
            // Если целевое значение находится в отсортированной левой части, обновляем верхнюю границу
            if (nums[low] <= target && target <= nums[mid]) high = mid - 1;
            else low = mid + 1; // Иначе обновляем нижнюю границу
        } else { // Если правая часть массива отсортирована
            // Если целевое значение находится в отсортированной правой части, обновляем нижнюю границу
            if (nums[mid] <= target && target <= nums[high]) low = mid + 1;
            else high = mid - 1; // Иначе обновляем верхнюю границу
        }
    }
    return false; // Если целевое значение не найдено, возвращаем false
}
