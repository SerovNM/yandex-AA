/**
 * Find Duplicate Subtrees
 * Дано бинарное дерево, в каждой вершине записана буква от A до Z (могут повторяться)
 * Вершины считаются эквивалентными, если в их деревьях записаны одинаковые множества букв
 * Найти 2 любых эквивалентных вершины
 */
/**
 *
 *
 * Главная идея этого решения состоит в использовании рекурсивного обхода бинарного дерева
 * с целью выявления дублирующихся поддеревьев. Для этого каждое поддерево преобразуется в строку,
 * и эти строки сравниваются для обнаружения дубликатов.
 */
var findDuplicateSubtrees = function(root) {
    let seen = {}; // Хранит подстроки каждого поддерева и их частоту встречаемости
    let output = []; // Хранит узлы дублирующихся поддеревьев

    traverse(root); // Вызываем функцию traverse для обхода дерева

    return output; // Возвращаем массив дублирующихся поддеревьев

    function traverse(node){
        if(!node) return "null"; // Если узел пустой, возвращаем строку "null"

        let left = traverse(node.left); // Рекурсивно обходим левое поддерево
        let right = traverse(node.right); // Рекурсивно обходим правое поддерево

        let key = `${node.val}-${left}-${right}`; // Формируем ключ для текущего поддерева

        seen[key] = (seen[key] || 0) + 1; // Увеличиваем счетчик встречаемости текущего поддерева
        if(seen[key] == 2) output.push(node); // Если поддерево дублируется второй раз, добавляем его узел в output

        return key; // Возвращаем строку, представляющую текущее поддерево
    }
};

/**
 * Каждое поддерево преобразуется в строку формата "значение_узла-левое_поддерево-правое_поддерево". Это позволяет идентифицировать поддерево с учетом его структуры и значений в узлах.
 *
 * Создается объект seen, который используется для хранения строк, представляющих поддеревья, и их частоты встречаемости.
 *
 * В ходе рекурсивного обхода дерева функция traverse строит строку для каждого поддерева и сохраняет ее в объекте seen. Если какая-то строка уже встречалась ранее, значит, мы обнаружили дублирующееся поддерево.
 *
 * Если строка уже встречалась в объекте seen, и ее частота встречаемости равна 2, то это означает, что мы уже добавили корень этого дублирующегося поддерева в массив output. Если необходимо найти два любых эквивалентных узла, можно просто завершить обход дерева после обнаружения первого дублирующегося поддерева.
 *
 * Функция findDuplicateSubtrees возвращает массив output, содержащий узлы дублирующихся поддеревьев.
 */
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

// Формирование бинарного дерева
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = null;
root.right.left = new TreeNode(2);
root.right.right = new TreeNode(4);
root.right.left.left = null;
root.right.left.right = null;
root.right.right.left = null;
root.right.right.right = new TreeNode(4);

// Вызов функции findDuplicateSubtrees с корнем дерева
console.log(findDuplicateSubtrees(root));


